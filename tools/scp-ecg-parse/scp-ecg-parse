#!/usr/bin/python3
# -*- coding: utf-8 -*-
"""
Parse an SCP-ECG electrocardiogram file and dump it in CSV format.
This is only a proof of concept script: it can handle only a subset
of the ANSI/AAMI EC71:2001 specifications.

Supported features:
  * Partial parsing of Sections #0, #1, #2, #3, #6.
  * Decode data stored using default SCP-ECG Huffman table.
  * Reconstruct data stored as "second differences" sequence.

Unsupported features:
  * Bimodal compression.
  * Custom Huffman tables.
  * Uncompressed data (no Huffman table).
  * Reference beat compression.
  * Many others...
"""

import os.path
import sys
import binascii
import huffman

__author__ = "Niccolo Rigacci"
__copyright__ = "Copyright 2020 Niccolo Rigacci <niccolo@rigacci.org>"
__license__ = "GPLv3-or-later"
__email__ = "niccolo@rigacci.org"
__version__ = "0.0.1"

SECTION_0_OFFSET = 6
SECTION_ID_HEADER_LEN = 16
SECTION_1_TAG_TERMINATOR = 255
POINTER_FIELD_LEN = 2 + 4 + 4
MIN_POINTER_FIELDS = 12
SEX_TAG = 8
SEX_VALUES = {0: u'Not Known', 1: u'Male', 2: u'Female', 9: u'Unspecified'}
ENCODING_TYPE = {0: 'Real (zero difference)', 1: 'First difference', 2: 'Second difference'}
BIMODAL_COMPR_TYPE = {0: 'Not used', 1: 'Bimodal'}
DEFAULT_HUFFMAN_TABLE = 19999

# Patient data in Section #1.
KNOWN_TAGS = {
    0: 'Patient Last Name',
    1: 'Patient First Name',
    2: 'Patient ID',
    3: 'Second Last Name',
    5: 'Patient Date of Birth',
    8: 'Patient Sex',
    10: 'Drugs',
    13: 'Diagnosis or Referral Indication',
    14: 'Acquiring Device Id Number',
    15: 'Analyzing Device Id Number',
    16: 'Acquiring Institution Description',
    17: 'Analyzing Institution Description',
    18: 'Acquiring Department Description',
    19: 'Analyzing Department Description',
    20: 'Referring Physician',
    21: 'Latest Confirming Physician',
    22: 'Technician Description',
    23: 'Room Description',
    25: 'Date of Acquisition',
    26: 'Time of Acquisition',
    30: 'Free Text',
    31: 'ECG Sequence Number',
    32: 'History diagnostic codes',
    34: 'Date Time Zone',
    35: 'Free-text Medical History'
}

# Lead Identification for data in Section #3.
LEAD = {
    1: 'I',
    2: 'II',
    3: 'V1',
    4: 'V2',
    5: 'V3',
    6: 'V4',
    7: 'V5',
    8: 'V6',
    9: 'V7',
    10: 'V2R',
    11: 'V3R',
    12: 'V4R',
    13: 'V5R',
    14: 'V6R',
    15: 'V7R',
    16: 'X',
    17: 'Y',
    18: 'Z',
    19: 'CC5',
    20: 'CM5',
    21: 'LA',
    22: 'RA',
    23: 'LL',
    24: 'I',
    25: 'E',
    26: 'C',
    27: 'A',
    28: 'M',
    29: 'F',
    30: 'H',
    31: 'I-cal',
    32: 'II-cal',
    33: 'V1-cal',
    34: 'V2-cal',
    35: 'V3-cal',
    36: 'V4-cal',
    37: 'V5-cal',
    38: 'V6-cal',
    39: 'V7-cal',
    40: 'V2R-cal',
    41: 'V3R-cal',
    42: 'V4R-cal',
    43: 'V5R-cal',
    44: 'V6R-cal',
    45: 'V7R-cal',
    46: 'X-cal',
    47: 'Y-cal',
    48: 'Z-cal',
    49: 'CC5-cal',
    50: 'CM5-cal',
    51: 'Left Arm-cal',
    52: 'Right Arm-cal',
    53: 'Left Leg-cal',
    54: 'I-cal',
    55: 'E-cal',
    56: 'C-cal',
    57: 'A-cal',
    58: 'M-cal',
    59: 'F-cal',
    60: 'H-cal',
    61: 'III',
    62: 'aVR',
    63: 'aVL',
    64: 'aVF'
}

MANDATORY_TAGS = [2, 14, 25, 26]
DATE_TAGS = [5, 25]
TIME_TAGS = [26]
ASCIIZ_TAGS = [0, 1, 2, 3, 13, 16, 17, 18, 19, 20, 21, 22, 23, 30, 31, 35]
MACHINE_ID_TAGS = [14, 15]


class second_diff():
    """ Reconstruct a sequence from Second Differences """
    def __init__(self):
        self.previous_val = None
        self.previous_diff1 = None
    def val(self, diff2):
        if self.previous_val == None:
            self.previous_val = diff2
            return diff2
        if self.previous_diff1 == None:
            self.previous_diff1 = diff2 - self.previous_val
            self.previous_val = diff2
            return diff2
        diff1 = self.previous_diff1 + diff2
        val = self.previous_val + diff1
        self.previous_val = val
        self.previous_diff1 = diff1
        return val


def read_section_header(fp, offset):
    """ Read a section header (16 bytes) and check the CRC """
    h = {}
    fp.seek(offset)
    h['crc'] = int.from_bytes(f.read(2), byteorder='little')
    h['id'] = int.from_bytes(f.read(2), byteorder='little')
    h['length'] = int.from_bytes(f.read(4), byteorder='little')
    h['version'] = int.from_bytes(f.read(1), byteorder='little')
    h['protocol'] = int.from_bytes(f.read(1), byteorder='little')
    h['reserved'] = f.read(6)
    f.seek(offset + 2)
    h['calc_crc'] = binascii.crc_hqx(f.read(h['length'] - 2), 0xffff)
    if h['crc'] != h['calc_crc']:
        print(u'ERROR: CRC check failed')
        sys.exit(1)
    return h


def print_section_header(i, h, label=''):
    print()
    print(u'==== Section #%d: %s ====' % (i, label))
    print(u'Section CRC:      0x%04X' % (h['crc'],))
    print(u'Section Id:       0x%04X' % (h['id'],))
    print(u'Section length:   %d'     % (h['length'],))
    print(u'Section version:  0x%02X' % (h['version'],))
    print(u'Protocol version: 0x%02X' % (h['protocol'],))
    print(u'Calculated CRC:   0x%04X' % (h['calc_crc'],))


def asciiz(byte_str):
    return byte_str.decode('utf-8').split('\0', 1)[0]


def read_parameter(fp):
    """ Read a parameter from patient data (Section #1) """
    tag = int.from_bytes(f.read(1), byteorder='little')
    length = int.from_bytes(f.read(2), byteorder='little')
    value = f.read(length)
    if tag in DATE_TAGS:
        value = parse_date(value)
    elif tag in TIME_TAGS:
        value = parse_time(value)
    elif tag in ASCIIZ_TAGS:
        value = asciiz(value)
    elif tag == SEX_TAG:
        value = int.from_bytes(value, byteorder='little')
        if value in SEX_VALUES:
            value = SEX_VALUES[value]
        else:
            value = u'Invalid %d' % (value)
    elif tag in MACHINE_ID_TAGS:
        value = parse_machine_id(value)
    if tag in KNOWN_TAGS:
        tag_label = KNOWN_TAGS[tag]
    else:
        tag_label = u'Unknown %d' % (tag,)
    return (tag, tag_label, length, value)


def parse_date(bytes):
    year = int.from_bytes(bytes[0:2], byteorder='little')
    month = int.from_bytes(bytes[2:3], byteorder='little')
    day = int.from_bytes(bytes[3:4], byteorder='little')
    if (month < 1 or month > 12) or (day < 1 or day > 31):
        print(u'WARNING: Invalid date: %s' % (bytes,))
        year, month, day = 0, 0, 0
    return '%04d-%02d-%02d' % (year, month, day)


def parse_time(bytes):
    hours = int.from_bytes(bytes[0:1], byteorder='little')
    minutes = int.from_bytes(bytes[1:2], byteorder='little')
    seconds = int.from_bytes(bytes[2:3], byteorder='little')
    if (hours > 23 or minutes > 59 or seconds > 59):
        hours, minutes, seconds = 0, 0, 0
    return '%02d:%02d:%02d' % (hours, minutes, seconds)


def parse_machine_id(bytes):
    institute_n  = int.from_bytes(bytes[1:3], byteorder='little')
    department_n = int.from_bytes(bytes[3:5], byteorder='little')
    device_id    = int.from_bytes(bytes[5:7], byteorder='little')
    device_type  = int.from_bytes(bytes[7:8], byteorder='little')
    model = asciiz(bytes[8:14])
    return 'Inst. %d, Dept. %d, Dev. %d, Type %d, Model %s' % (institute_n, department_n, device_id, device_type, model)


#-------------------------------------------------------------------------
# Main program.
#-------------------------------------------------------------------------
if len(sys.argv) < 2:
    print('Usage: %s [file.ecg]' % (os.path.basename(sys.argv[0],)))
    sys.exit(1)

filename = sys.argv[1]
if not os.path.exists(filename):
    print(u'ERROR: Input file %s does not exists' % (filename,))
    sys.exit(1)

# Get some metadata from file size.
file_size = os.path.getsize(filename)

f = open(filename, 'rb')

# ==== SCP-ECG Record, check CRC and length ====

# CRC is actually a byte by byte CRC-CCITT (0xFFFF)
record_crc = int.from_bytes(f.read(2), byteorder='little')
record_length = int.from_bytes(f.read(4), byteorder='little')
print(u'==== SCP-ECG Record ====')
print(u'File size:      %d bytes' % (file_size,))
print(u'Record CRC:     0x%04X' % (record_crc,))
print(u'Record length:  %d bytes' % (record_length,))
f.seek(2)
calculated_crc = binascii.crc_hqx(f.read(record_length - 2), 0xffff)
print(u'Calculated CRC: 0x%04X' % (calculated_crc,))
if record_crc != calculated_crc:
    print(u'ERROR: CRC check failed')
    sys.exit(1)
if file_size != record_length:
    print(u'ERROR: File length does not match record length')
    sys.exit(1)


# ==== Section #0 is the Pointer Section (mandatory) ====

# Section #0: Section ID Header
h = read_section_header(f, SECTION_0_OFFSET)
print_section_header(0, h, u'Section Pointers')
if h['reserved'].decode('utf-8') != u'SCPECG':
    print(u'ERROR: Missing signature "SCPECG" in Section 0')
    sys.exit(1)

# Section #0: Data Part
# Contains Pointer Fields for sections 0-11, plus manufacturer sections if any.
# NOTICE: There is a pointer section for section 0 too.
data_part_length = h['length'] - SECTION_ID_HEADER_LEN
print(u'Data Part length: %d' % (data_part_length,))
if (data_part_length % POINTER_FIELD_LEN) != 0:
    print(u'WARNING: Data part of section #0 is %d bytes, not a multiple of %d (pointer field size)' % (data_part_length, POINTER_FIELD_LEN))
pointer_fields = int(data_part_length / POINTER_FIELD_LEN)
print(u'Pointer Fields:   %d' % (pointer_fields,))

if pointer_fields < MIN_POINTER_FIELDS:
    print(u'WARNING: Only %d pointer fields found, should be at least %d' % (pointer_fields, MIN_POINTER_FIELDS))

f.seek(SECTION_0_OFFSET + SECTION_ID_HEADER_LEN)
section_pointers = {}
for i in range(0, pointer_fields):
    section_id = int.from_bytes(f.read(2), byteorder='little')
    section_len = int.from_bytes(f.read(4), byteorder='little')
    section_index = int.from_bytes(f.read(4), byteorder='little')
    if section_len != 0:
        section_pointers[i] = {'idx': section_index, 'length': section_len}
        print()
        print(u'==== Pointer for Section #%d ====' % (i,))
        print(u'Section Id:     0x%04X' % (section_id,))
        print(u'Section index:  0x%08X' % (section_index,))
        print(u'Section length: %d'     % (section_len,))
        if section_id != i:
            print(u'WARNING: Searching section pointer %d, found Id %d' % (i, section_id))


# ==== Section #1 contains the Patient Data (mandatory) ====

# Section indexes are 1-based.
section_index = section_pointers[1]['idx'] - 1
section_length = section_pointers[1]['length']
h = read_section_header(f, section_index)
print_section_header(1, h, u'Patient Data')
if h['id'] != 1:
    print(u'ERROR: Searching section #%d, found Id %d' % (1, h['id']))
    sys.exit(1)
f.seek(section_index + SECTION_ID_HEADER_LEN)
read_len = 0
print()
while read_len < (section_length - SECTION_ID_HEADER_LEN):
    tag, tag_label, length, value = read_parameter(f)
    if tag == SECTION_1_TAG_TERMINATOR:
        break
    print(u'Tag: %s: %s' % (tag_label, value))
    read_len += (1 + 2 + length)


# ==== Section #2 contains the Huffman tables (optional) ====
section_index = section_pointers[2]['idx'] - 1
section_length = section_pointers[2]['length']
if section_length == 0:
    using_huffman = False
else:
    using_huffman = True
    h = read_section_header(f, section_index)
    print_section_header(2, h, u'Huffman tables')
    if h['id'] != 2:
        print(u'ERROR: Searching section #%d, found Id %d' % (2, h['id']))
        sys.exit(1)
    f.seek(section_index + SECTION_ID_HEADER_LEN)
    tables_num = int.from_bytes(f.read(2), byteorder='little')
    print()
    if tables_num == DEFAULT_HUFFMAN_TABLE:
        print(u'INFO: Using SCP-ECG default Huffman table')
    else:
        print(u'ERROR: Using custom Huffman table #%d not supported' % (tables_num,))
        sys.exit(1)


# ==== Section #3 contains ECG lead definition (optional) ====
section_index = section_pointers[3]['idx'] - 1
section_length = section_pointers[3]['length']
if section_length == 0:
    print(u'ERROR: Section #3 (ECG lead definition) not found')
    sys.exit(1)
h = read_section_header(f, section_index)
print_section_header(3, h, u'ECG lead definition')
if h['id'] != 3:
    print(u'ERROR: Searching section #%d, found Id %d' % (3, h['id']))
    sys.exit(1)
f.seek(section_index + SECTION_ID_HEADER_LEN)
leads_number = int.from_bytes(f.read(1), byteorder='little')
flag_byte = int.from_bytes(f.read(1), byteorder='little')
ref_beat     = (flag_byte & 0b00000001) == 0b001
simult_read  = (flag_byte & 0b00000100) == 0b100
lead_simult  = (flag_byte & 0b11111000) >> 3
print()
print(u'Leads: %d' % (leads_number,))
print(u'Flag byte: %s' % (bin(flag_byte),))
print(u'Reference beat: %s' % (ref_beat,))
print(u'Simultaneous read: %s' % (simult_read,))
print(u'Leads simulteaneous: %d' % (lead_simult,))
lead_sample_num = {}
max_sample_num = 0
for i in range(0, leads_number):
    # Sample numbering is 1-based.
    starting_sample = int.from_bytes(f.read(4), byteorder='little')
    ending_sample = int.from_bytes(f.read(4), byteorder='little')
    lead_id = int.from_bytes(f.read(1), byteorder='little')
    lead_sample_num[i] = {'start': starting_sample, 'end': ending_sample}
    if ending_sample > max_sample_num:
        max_sample_num = ending_sample
    print(u'Lead #%02d %4s - Sampling interval: %d - %d' % (i, LEAD[lead_id], starting_sample, ending_sample))


# ==== Section #6 contains the rhythm data (optional) ====
section_index = section_pointers[6]['idx'] - 1
section_length = section_pointers[6]['length']
if section_length == 0:
    print(u'ERROR: Section #6 (rhythm data) not found')
    sys.exit(1)
h = read_section_header(f, section_index)
print_section_header(6, h, u'Rhythm Data')
if h['id'] != 6:
    print(u'ERROR: Searching section #%d, found Id %d' % (6, h['id']))
    sys.exit(1)
#  The section contains the entire ECG rhythm data, if no reference beats have been subtracted.
if ref_beat:
    print(u'ERROR: Unsupported rhythm using reference beat compression')
    sys.exit(1)
f.seek(section_index + SECTION_ID_HEADER_LEN)
amplitude_multiplier = int.from_bytes(f.read(2), byteorder='little')  # Nanovolt
sample_time_interval = int.from_bytes(f.read(2), byteorder='little')  # Microseconds
encoding_diff = int.from_bytes(f.read(1), byteorder='little')
bimodal_compr = int.from_bytes(f.read(1), byteorder='little')
if encoding_diff not in ENCODING_TYPE:
    print(u'ERROR: Unknown encoding %d' % (encoding_diff,))
if bimodal_compr not in BIMODAL_COMPR_TYPE:
    print(u'ERROR: Unknown compression %d' % (bimodal_compr,))
print()
print(u'Amplitude multiplier: %d nV' % (amplitude_multiplier,))
print(u'Sample time interval: %d us' % (sample_time_interval,))
print(u'Encoding difference: %s' % (ENCODING_TYPE[encoding_diff],))
print(u'Bimodal compression: %s' % (BIMODAL_COMPR_TYPE[bimodal_compr],))
print(u'Using Huffman table: %s' % (using_huffman,))
stored_bytes_lead = {}
for i in range(0, leads_number):
    stored_bytes_lead[i] = int.from_bytes(f.read(2), byteorder='little')
    print(u'Bytes for lead #%d: %d' % (i, stored_bytes_lead[i]))

ecg_data = {}
for lead in range(0, leads_number):
    data_bytes = f.read(stored_bytes_lead[lead])  # data_bytes is of type <class 'bytes'>
    print()
    print('==== Read %d bytes for lead #%d' % (len(data_bytes), lead))
    if bimodal_compr != 0:
        print(u'ERROR: Unsupported "%s" compression' % (BIMODAL_COMPR_TYPE[bimodal_compr],))
        continue
    if using_huffman:
        bit_decoder = huffman.decoder()
    else:
        print(u'ERROR: Unsupported ECG data not using Huffman table (should read signed two-bytes integers)')
        continue
    if encoding_diff == 2:
        sequence = second_diff()
        sample_num = lead_sample_num[lead]['start']
        for diff in bit_decoder.decode(data_bytes):
            val = sequence.val(diff)
            ecg_data[(sample_num, lead)] = val
            sample_num += 1
        # Actual number of samples can differ from Section #3 declarations.
        print(u'INFO: Lead %d: found %d samples' % (lead, sample_num))
    else:
        print(u'ERROR: Unsupported encoding mode: "%s"' % (ENCODING_TYPE[encoding_diff],))
        continue

# Dump the full time serie, in CSV format.
print()
print(u'==== ECG data dump in CSV format ====')
for sample_num in range(1, (max_sample_num + 1)):
    values_row = []
    for lead in range(0, leads_number):
        if (sample_num, lead) in ecg_data:
            values_row.append('%.6f' % (ecg_data[(sample_num, lead)] * (amplitude_multiplier / 1000.0),))
        else:
            values_row.append('')
    print(','.join(values_row))

f.close()
